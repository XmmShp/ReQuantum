using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ReQuantum;

/// <summary>
/// 源生成器：检测标记了AutoInjectAttribute的服务类，并生成注册代码
/// </summary>
[Generator]
public class AutoInjectGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 获取所有带有AutoInjectAttribute的类
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // 注册输出生成
        var compilationAndClasses
            = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    /// <summary>
    /// 判断语法节点是否是我们关注的目标（带有Attribute的类声明）
    /// </summary>
    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        // 只关注类声明
        if (node is ClassDeclarationSyntax classDeclaration)
        {
            // 检查类是否有特性列表
            return classDeclaration.AttributeLists.Count > 0;
        }
        return false;
    }

    /// <summary>
    /// 获取语义模型中的目标类（带有AutoInjectAttribute的类）
    /// </summary>
    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        // 获取类的语义模型
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
        if (classSymbol is null)
        {
            return null;
        }

        // 检查类是否有AutoInjectAttribute
        var hasAutoInjectAttribute = classSymbol.GetAttributes()
            .Any(attr => attr.AttributeClass?.ToDisplayString().EndsWith("AutoInjectAttribute") == true);

        return hasAutoInjectAttribute ? classDeclaration : null;
    }

    /// <summary>
    /// 执行代码生成
    /// </summary>
    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        // 获取所有带有AutoInjectAttribute的类的符号
        var serviceClasses = new List<INamedTypeSymbol>();
        foreach (var classDeclaration in classes)
        {
            if (classDeclaration is null)
            {
                continue;
            }

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclaration) is { IsAbstract: false } classSymbol &&
                classSymbol.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString().EndsWith("AutoInjectAttribute") == true))
            {
                serviceClasses.Add(classSymbol);
            }
        }

        if (serviceClasses.Count == 0)
        {
            return;
        }

        // 生成服务注册扩展方法
        var source = GenerateServiceRegistrationExtension(serviceClasses);
        context.AddSource("ServiceCollectionExtensions.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    /// <summary>
    /// 生成服务注册扩展方法的代码
    /// </summary>
    private static string GenerateServiceRegistrationExtension(List<INamedTypeSymbol> serviceClasses)
    {
        var ns = string.Empty;
        if (serviceClasses.FirstOrDefault() is { } service)
        {
            ns = service.ContainingAssembly.Name;
        }
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using System;");
        sb.AppendLine();
        sb.AppendLine($"namespace {ns}.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// 自动生成的服务注册扩展方法");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class ServiceCollectionExtensions");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// 自动注册所有标记了AutoInjectAttribute的服务");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <param name=\"services\">服务集合</param>");
        sb.AppendLine("        /// <returns>用于链式调用的服务集合</returns>");
        sb.AppendLine("        public static IServiceCollection AutoAddGeneratedServices(this IServiceCollection services)");
        sb.AppendLine("        {");

        // 为每个服务类生成注册代码
        foreach (var serviceClass in serviceClasses)
        {
            GenerateServiceRegistration(sb, serviceClass);
        }

        sb.AppendLine("            return services;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// 为单个服务类生成注册代码
    /// </summary>
    private static void GenerateServiceRegistration(StringBuilder sb, INamedTypeSymbol serviceClass)
    {
        // 获取AutoInjectAttribute
        var attribute = serviceClass.GetAttributes()
            .First(attr => attr.AttributeClass?.ToDisplayString().EndsWith("AutoInjectAttribute") == true);

        // 获取生命周期
        var lifetime = "ServiceLifetime.Transient"; // 默认值
        if (attribute.ConstructorArguments.Length > 0)
        {
            var lifetimeArg = attribute.ConstructorArguments[0];
            lifetime = $"ServiceLifetime.{(Lifetime)lifetimeArg.Value!}";
        }

        // 获取要注册的类型
        var registerTypesExpr = attribute.NamedArguments
            .FirstOrDefault(kvp => kvp.Key == "RegisterTypes").Value;

        var hasExplicitRegisterTypes = !registerTypesExpr.IsNull;

        var serviceTypeName = serviceClass.ToDisplayString();

        // 当生命周期是Singleton或Scoped时，特殊处理
        if (lifetime == "ServiceLifetime.Singleton" || lifetime == "ServiceLifetime.Scoped")
        {
            var typesToRegister = new HashSet<string>();

            if (hasExplicitRegisterTypes)
            {
                foreach (var typeName in registerTypesExpr.Values
                             .Select(type => type.Value?.ToString() ?? "")
                             .Where(typeName => !string.IsNullOrEmpty(typeName)))
                {
                    typesToRegister.Add(typeName);
                }
            }
            else
            {
                var interfaces = serviceClass.AllInterfaces;
                foreach (var @interface in interfaces)
                {
                    typesToRegister.Add(@interface.ToDisplayString());
                }
            }

            // 如果只有一种类型需要注册（只有一个接口或显式类型），则直接注册为该类型
            if (typesToRegister.Count == 1)
            {
                sb.AppendLine($"            services.Add(new ServiceDescriptor(typeof({typesToRegister.First()}), typeof({serviceTypeName}), {lifetime}));");
            }
            else
            {
                // 如果有多种类型需要注册或没有类型需要注册，先注册实现类本身
                sb.AppendLine($"            services.Add(new ServiceDescriptor(typeof({serviceTypeName}), typeof({serviceTypeName}), {lifetime}));");

                // 然后注册所有需要的类型
                foreach (var typeName in typesToRegister.Where(type => type != serviceTypeName))
                {
                    sb.AppendLine($"            services.Add(new ServiceDescriptor(typeof({typeName}), sp => sp.GetRequiredService(typeof({serviceTypeName})), {lifetime}));");
                }
            }
        }
        else // Transient生命周期
        {
            if (hasExplicitRegisterTypes)
            {
                foreach (var typeName in registerTypesExpr.Values
                             .Select(typeArg => typeArg.Value?.ToString() ?? "")
                             .Where(typeName => !string.IsNullOrEmpty(typeName)))
                {
                    sb.AppendLine($"            services.Add(new ServiceDescriptor(typeof({typeName}), typeof({serviceTypeName}), {lifetime}));");
                }
            }
            else
            {
                // 使用实现的所有接口
                var interfaces = serviceClass.AllInterfaces;
                if (interfaces.Length > 0)
                {
                    foreach (var faceName in interfaces.Select(face => face.ToDisplayString()))
                    {
                        sb.AppendLine($"            services.Add(new ServiceDescriptor(typeof({faceName}), typeof({serviceTypeName}), {lifetime}));");
                    }
                }
                else
                {
                    // 如果没有接口，则注册自身
                    sb.AppendLine($"            services.Add(new ServiceDescriptor(typeof({serviceTypeName}), typeof({serviceTypeName}), {lifetime}));");
                }
            }
        }

        sb.AppendLine();
    }
}
public enum Lifetime
{
    Singleton = 0,
    Scoped = 1,
    Transient = 2
}
